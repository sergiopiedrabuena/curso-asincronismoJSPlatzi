ü™É Un callback devuelve una funci√≥n en los par√°metros, cuando llamamos varias veces un callback, estaremos colocando muchas lineas de c√≥digo y ser√≠a engorroso, por eso nacen las promesas, √©stas optimizan y permiten leer mejor el c√≥digo con pocas lineas.
.
ü´±üèº‚Äçü´≤üèæ Las promesas son as√≠ncronas, por lo que el c√≥digo continuar√° su ejecuci√≥n normalmente y luego dir√° si la promesa se resolvi√≥ o se rechaz√≥. Por lo que varias promesas pueden llegar a entrar en ejecuci√≥n al mismo tiempo.
.
Las promesas pueden suceder:
.

Ahora
En el futuro
Nunca
.
üõ†Ô∏è Para crear una promesa:
.
Utilizamos la palabra reservada new seguida de la palabra Promise que es el constructor de la promesa. Este constructor recibe un √∫nico par√°metro que es una funci√≥n, la cu√°l a su vez, recibe otros dos par√°metros: resolve y reject.

El par√°metro resolve se utiliza para cuando la promesa devuelve el valor correctamente.
El par√°metro reject, se usa en el que caso de que no funcione.
.

üóÉÔ∏è Una Promesa puede estar en uno de los siguientes estados:
.

Pendiente pending ‚Üí Una promesa inicia en este estado: no cumplida, no rechazada:
Una promesa inicialmente est√° pendiente.
Cumplida fulfilled ‚Üí Significa que la operaci√≥n se complet√≥ satisfactoriamente, .then(va => ‚Ä¶)
Cuando llamamos a resolve entonces la promesa pasa a estar resuelta.
Cuando una promesa se resuelve entonces se ejecuta la funci√≥n que pasamos al m√©todo .then
Rechazada rejected ‚Üí significa que la operaci√≥n fall√≥, .catch(err => ‚Ä¶)
Si llamamos a reject pasa a estar rechazada (obtenemos un error que nos va a indicar la raz√≥n del rechazo).
Si la promesa es rechazada entonces se ejecuta la funci√≥n que pasamos a .catch
.

Informacion cedida por: Maria Gabriela Rodriguez Cuevas